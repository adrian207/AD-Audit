name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  release:
    types: [ published ]

env:
  POWERSHELL_VERSION: '7.4.0'
  PESTER_VERSION: '5.7.1'

jobs:
  test:
    name: Run Tests
    runs-on: windows-latest
    strategy:
      matrix:
        pwsh-version: ['7.4', '5.1']
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup PowerShell Core
      if: matrix.pwsh-version != '5.1'
      shell: pwsh
      run: |
        Write-Host "Using PowerShell Core ${{ matrix.pwsh-version }}"
        $PSVersionTable
        
    - name: Setup Windows PowerShell
      if: matrix.pwsh-version == '5.1'
      shell: powershell
      run: |
        Write-Host "Using Windows PowerShell ${{ matrix.pwsh-version }}"
        $PSVersionTable
        
    - name: Install Dependencies
      shell: pwsh
      run: |
        Install-Module -Name Pester -Force -SkipPublisherCheck -Scope CurrentUser -MinimumVersion ${{ env.PESTER_VERSION }}
        Install-Module -Name PSScriptAnalyzer -Force -SkipPublisherCheck -Scope CurrentUser
        
    - name: Run PSScriptAnalyzer
      shell: pwsh
      run: |
        $results = Invoke-ScriptAnalyzer -Path . -Recurse -Severity @('Error', 'Warning') -ExcludeRule PSAvoidUsingWriteHost
        if ($results) {
          Write-Host "ScriptAnalyzer found $($results.Count) issues:" -ForegroundColor Yellow
          $results | ForEach-Object { Write-Host "  $($_.Severity): $($_.Message) at $($_.ScriptPath):$($_.Line)" }
          
          $errorCount = ($results | Where-Object Severity -eq 'Error').Count
          if ($errorCount -gt 0) {
            Write-Host "##vso[task.logissue type=error]Found $errorCount error(s)"
            exit 1
          }
        } else {
          Write-Host "No ScriptAnalyzer issues found" -ForegroundColor Green
        }
        
    - name: Run Pester Tests
      shell: pwsh
      run: |
        if (Test-Path "Tests/") {
          cd Tests
          $testFiles = Get-ChildItem -Path "*.Tests.ps1" -ErrorAction SilentlyContinue
          if ($testFiles) {
            $testResults = Invoke-Pester -Path "*.Tests.ps1" -OutputFile "TestResults.xml" -OutputFormat NUnitXml -PassThru
            
            Write-Host "Test Results:" -ForegroundColor Cyan
            Write-Host "  Passed: $($testResults.PassedCount)" -ForegroundColor Green
            Write-Host "  Failed: $($testResults.FailedCount)" -ForegroundColor $(if($testResults.FailedCount -gt 0){'Red'}else{'Green'})
            Write-Host "  Total: $($testResults.TotalCount)" -ForegroundColor White
            
            if ($testResults.TotalCount -gt 0) {
              $successRate = [math]::Round(($testResults.PassedCount / $testResults.TotalCount) * 100, 2)
              Write-Host "  Success Rate: $successRate%" -ForegroundColor Cyan
            }
            
            if ($testResults.FailedCount -gt 0) {
              Write-Host "##vso[task.logissue type=error]$($testResults.FailedCount) test(s) failed"
              exit 1
            } else {
              Write-Host "All Pester tests passed: $($testResults.PassedCount) tests" -ForegroundColor Green
            }
          } else {
            Write-Host "No test files found in Tests directory" -ForegroundColor Yellow
          }
        } else {
          Write-Host "Tests directory not found" -ForegroundColor Yellow
        }
        
    - name: Upload Test Results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results-${{ matrix.pwsh-version }}
        path: Tests/TestResults.xml
        retention-days: 30
        
    - name: Test Module Import
      shell: pwsh
      run: |
        try {
          Import-Module .\AD-Audit.psd1 -Force
          Write-Host "Module imported successfully" -ForegroundColor Green
          
          # Test exported functions
          $exportedFunctions = (Get-Module AD-Audit).ExportedFunctions.Keys
          Write-Host "Exported functions: $($exportedFunctions.Count)" -ForegroundColor Cyan
          $exportedFunctions | ForEach-Object { Write-Host "  - $_" }
          
        } catch {
          Write-Host "Module import failed: $_" -ForegroundColor Red
          exit 1
        }

  security-scan:
    name: Security Scan
    runs-on: windows-latest
    needs: test
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
        
    - name: Install Security Scanning Tools
      run: |
        Install-Module -Name PSScriptAnalyzer -Force -SkipPublisherCheck -Scope CurrentUser
        
    - name: Security Analysis - Hardcoded Credentials
      run: |
        $credentialPatterns = @(
          'password\s*=\s*["''][^"'']+["'']',
          'pwd\s*=\s*["''][^"'']+["'']',
          'pass\s*=\s*["''][^"'']+["'']',
          'secret\s*=\s*["''][^"'']+["'']',
          'key\s*=\s*["''][^"'']+["'']',
          'token\s*=\s*["''][^"'']+["'']'
        )
        
        $searchPaths = @()
        if (Test-Path "Modules/") { $searchPaths += "Modules/" }
        if (Test-Path "Libraries/") { $searchPaths += "Libraries/" }
        if (Test-Path "Tests/") { $searchPaths += "Tests/" }
        
        if ($searchPaths.Count -gt 0) {
          $files = Get-ChildItem -Path $searchPaths -Recurse -Include "*.ps1" -ErrorAction SilentlyContinue
          $securityIssues = @()
          
          foreach ($file in $files) {
            try {
              $content = Get-Content $file.FullName -Raw -ErrorAction Stop
              foreach ($pattern in $credentialPatterns) {
                if ($content -match $pattern) {
                  $securityIssues += "Potential hardcoded credential in $($file.FullName)"
                }
              }
            } catch {
              Write-Warning "Could not read file: $($file.FullName)"
            }
          }
          
          if ($securityIssues.Count -gt 0) {
            Write-Host "Security issues found:" -ForegroundColor Red
            $securityIssues | ForEach-Object { Write-Host "  $_" }
            exit 1
          } else {
            Write-Host "No hardcoded credentials found" -ForegroundColor Green
          }
        } else {
          Write-Host "No source directories found for security scanning" -ForegroundColor Yellow
        }
        
    - name: Security Analysis - Script Analyzer Security Rules
      run: |
        $securityRules = @(
          'PSAvoidUsingPlainTextForPassword',
          'PSAvoidUsingConvertToSecureStringWithPlainText',
          'PSAvoidUsingUsernameAndPasswordParams',
          'PSAvoidUsingInvokeExpression',
          'PSAvoidUsingCmdletAliases',
          'PSAvoidUsingPositionalParameters',
          'PSAvoidUsingEmptyCatchBlock',
          'PSAvoidUsingWMICmdlet'
        )
        
        $searchPaths = @()
        if (Test-Path "Modules/") { $searchPaths += "Modules/" }
        if (Test-Path "Libraries/") { $searchPaths += "Libraries/" }
        
        if ($searchPaths.Count -gt 0) {
          $results = Invoke-ScriptAnalyzer -Path $searchPaths -Recurse -IncludeRule $securityRules -ErrorAction SilentlyContinue
          if ($results) {
            Write-Host "Security rule violations found:" -ForegroundColor Red
            $results | Format-Table -AutoSize
            exit 1
          } else {
            Write-Host "No security rule violations found" -ForegroundColor Green
          }
        } else {
          Write-Host "No source directories found for security rule analysis" -ForegroundColor Yellow
        }

  build:
    name: Build Package
    runs-on: windows-latest
    needs: [test, security-scan]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
        
    - name: Create Release Package
      shell: pwsh
      run: |
        # Create release directory
        $releaseDir = ".\Release"
        New-Item -Path $releaseDir -ItemType Directory -Force
        
        # Copy module files
        Copy-Item -Path ".\AD-Audit.psd1" -Destination $releaseDir
        Copy-Item -Path ".\Modules" -Destination $releaseDir -Recurse
        Copy-Item -Path ".\Libraries" -Destination $releaseDir -Recurse
        Copy-Item -Path ".\Utilities" -Destination $releaseDir -Recurse
        Copy-Item -Path ".\docs" -Destination $releaseDir -Recurse
        Copy-Item -Path ".\Tests" -Destination $releaseDir -Recurse
        Copy-Item -Path ".\README.md" -Destination $releaseDir
        Copy-Item -Path ".\LICENSE" -Destination $releaseDir
        Copy-Item -Path ".\CHANGELOG.md" -Destination $releaseDir
        
        # Create ZIP package
        $version = if ($env:GITHUB_REF_NAME -match '^v(\d+\.\d+\.\d+)$') { $matches[1] } else { "dev" }
        Compress-Archive -Path "$releaseDir\*" -DestinationPath "AD-Audit-v$version.zip" -Force
        
        Write-Host "Release package created: AD-Audit-v$version.zip" -ForegroundColor Green
        
    - name: Upload Release Package
      uses: actions/upload-artifact@v4
      with:
        name: AD-Audit-Release
        path: AD-Audit-v*.zip
        retention-days: 30

  publish-gallery:
    name: Publish to PowerShell Gallery
    runs-on: windows-latest
    needs: [test, security-scan, build]
    if: github.event_name == 'release'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
        
    - name: Install PowerShellGet
      shell: pwsh
      run: |
        Install-Module -Name PowerShellGet -Force -SkipPublisherCheck
        
    - name: Publish to PowerShell Gallery
      shell: pwsh
      env:
        POWERSHELL_GALLERY_API_KEY: ${{ secrets.POWERSHELL_GALLERY_API_KEY }}
      run: |
        if (-not $env:POWERSHELL_GALLERY_API_KEY) {
          Write-Host "Error: POWERSHELL_GALLERY_API_KEY secret is not configured" -ForegroundColor Red
          Write-Host "Please add the secret in GitHub repository settings under Settings > Secrets and variables > Actions" -ForegroundColor Yellow
          exit 1
        }
        
        try {
          Publish-Module -Path . -NuGetApiKey $env:POWERSHELL_GALLERY_API_KEY -Force
          Write-Host "Module published to PowerShell Gallery successfully" -ForegroundColor Green
        } catch {
          Write-Host "Failed to publish module: $_" -ForegroundColor Red
          exit 1
        }

  documentation:
    name: Documentation Validation
    runs-on: windows-latest
    needs: test
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
        
    - name: Validate Documentation Structure
      run: |
        $requiredDocs = @(
          "README.md",
          "docs/README.md",
          "docs/USER_GUIDE.md",
          "docs/MODULE_REFERENCE.md"
        )
        
        $missingDocs = @()
        foreach ($doc in $requiredDocs) {
          if (-not (Test-Path $doc)) {
            $missingDocs += $doc
          }
        }
        
        if ($missingDocs.Count -gt 0) {
          Write-Host "Missing required documentation:" -ForegroundColor Red
          $missingDocs | ForEach-Object { Write-Host "  $_" }
          exit 1
        } else {
          Write-Host "All required documentation present" -ForegroundColor Green
        }
        
    - name: Validate Markdown Syntax
      run: |
        if (Test-Path "docs/") {
          $markdownFiles = Get-ChildItem -Path "docs/" -Recurse -Include "*.md" -ErrorAction SilentlyContinue
          $syntaxErrors = @()
          
          foreach ($file in $markdownFiles) {
            try {
              $content = Get-Content $file.FullName -Raw -ErrorAction Stop
              
              # Check for common markdown issues
              if ($content -match '\[.*\]\(.*\)') {
                # Check for relative links that might be broken
                $links = [regex]::Matches($content, '\[([^\]]+)\]\(([^)]+)\)')
                foreach ($link in $links) {
                  $linkPath = $link.Groups[2].Value
                  if ($linkPath -notmatch '^https?://' -and $linkPath -notmatch '^#' -and $linkPath -notmatch '^mailto:') {
                    $fullPath = Join-Path (Split-Path $file.FullName) $linkPath
                    if (-not (Test-Path $fullPath)) {
                      $syntaxErrors += "Broken link in $($file.Name): $linkPath"
                    }
                  }
                }
              }
            } catch {
              Write-Warning "Could not validate file: $($file.FullName)"
            }
          }
          
          if ($syntaxErrors.Count -gt 0) {
            Write-Host "Markdown syntax issues found:" -ForegroundColor Red
            $syntaxErrors | ForEach-Object { Write-Host "  $_" }
            exit 1
          } else {
            Write-Host "Markdown syntax validation passed" -ForegroundColor Green
          }
        } else {
          Write-Host "docs directory not found, skipping markdown validation" -ForegroundColor Yellow
        }
